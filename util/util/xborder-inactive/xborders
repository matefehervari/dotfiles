#!/bin/python3
from collections.abc import Generator
import cairo
import gi

gi.require_version("Gtk", "3.0")
gi.require_version("Gdk", "3.0")
gi.require_version("Wnck", "3.0")

import argparse
import json
import re
import subprocess
import sys
import time

from pipe import select, where
from gi.repository import Gdk, Gtk, Wnck  # noqa: E402
from i3_info import get_floating_window_ids, get_ordered_window_ids, get_active_window
from util import Get, Call, Is, tolist, toset, whereby

import draw

BORDER_RADIUS = 14
BORDER_WIDTH = 4
BORDER_R = 123
BORDER_G = 88
BORDER_B = 220
BORDER_A = 1
VIEWABLE_WINDOW_MAP_UPDATE_FREQUENCY = 0.05
VIEWABLE_WINDOW_MAP_CLEANUP_FREQUENCY = 80.0


class WinDim:
    x: int
    y: int
    width: int
    height: int

    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height

    def unpack(self):
        return (self.x, self.y, self.width, self.height)


class WinData:
    id: int
    dim: WinDim

    def __init__(self, id, *args):
        self.id = id
        self.dim = WinDim(*args)


def set_border_rgba(args):
    literal_value = 0
    try:
        literal_value = int(args.border_rgba.replace("#", "0x"), 16)
    except Exception as _:
        print(
            f"`{args.border_rgba}` is an invalid hexadecimal number!",
            file=sys.stderr,
        )
        sys.exit(1)
    args.border_red = literal_value >> (3 * 8) & 0xFF
    args.border_green = literal_value >> (2 * 8) & 0xFF
    args.border_blue = literal_value >> (1 * 8) & 0xFF
    args.border_alpha = (literal_value >> (0 * 8) & 0xFF) / 255  # map from 0 to 1


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--config", "-c", type=str, help="The path to the config file")
    parser.add_argument(
        "--border-radius", type=int, default=14, help="The border radius, in pixels"
    )
    parser.add_argument(
        "--border-width", type=int, default=4, help="The border width in pixels"
    )
    parser.add_argument(
        "--border-red",
        type=int,
        default=123,
        help="The border's red value, between 0 and 255",
    )
    parser.add_argument(
        "--border-green",
        type=int,
        default=88,
        help="The border's green value, between 0 and 255",
    )
    parser.add_argument(
        "--border-blue",
        type=int,
        default=220,
        help="The border's blue value, between 0 and 255",
    )
    parser.add_argument(
        "--border-alpha",
        type=float,
        default=1,
        help="The border's alpha value, between zero and 1",
    )
    parser.add_argument(
        "--border-rgba",
        default=None,
        help="The colours of the border in hex format, example: #FF0000FF",
    )
    parser.add_argument(
        "--border-mode",
        type=str,
        default="outside",
        help="Whether to place the border on the outside, inside or in the center of windows. Values are `outside`, `inside`, `center`",
    )
    args = parser.parse_args()
    if args.border_rgba is not None:
        set_border_rgba(args)

    # Extract the literal values

    if args.config is not None:
        with open(args.config, "r") as f:
            raw = f.read().replace("-", "_")
            dat = json.loads(raw)
            for ident in dat:
                if ident == "border_rgba":
                    args.border_rgba = dat[ident]
                    set_border_rgba(args)
                else:
                    args.__dict__[ident] = dat[ident]

    global BORDER_RADIUS
    global BORDER_WIDTH
    global BORDER_MODE
    global BORDER_R
    global BORDER_G
    global BORDER_B
    global BORDER_A

    BORDER_RADIUS = args.border_radius
    BORDER_WIDTH = args.border_width
    BORDER_R = args.border_red
    BORDER_G = args.border_green
    BORDER_B = args.border_blue
    BORDER_A = args.border_alpha
    if args.border_mode == "inside":
        BORDER_MODE = 0
    elif args.border_mode == "outside":
        BORDER_MODE = 1
    elif args.border_mode == "center":
        BORDER_MODE = 2
    else:
        raise ValueError(f"Invalid border_mode '{args.border_mode}'")

    return


is_fullscreen_cache = False
last_is_fullscreen_test = True


def is_fullscreen(wnck_screen) -> bool:
    global is_fullscreen_cache, last_is_fullscreen_test
    if time.time() - last_is_fullscreen_test < 0.1:
        return is_fullscreen_cache

    active_window = wnck_screen.get_active_window()
    if active_window:
        state = active_window.get_state()
        is_fullscreen_cache = state == Wnck.WindowState.FULLSCREEN
    else:
        is_fullscreen_cache = False
    last_is_fullscreen_test = time.time()
    return is_fullscreen_cache


def get_screen_size(display):  # TODO: Multiple monitor size support
    mon_geoms = [
        display.get_monitor(i).get_geometry() for i in range(display.get_n_monitors())
    ]

    x0 = min(r.x for r in mon_geoms)
    y0 = min(r.y for r in mon_geoms)
    x1 = max(r.x + r.width for r in mon_geoms)
    y1 = max(r.y + r.height for r in mon_geoms)

    return x1 - x0, y1 - y0


root = Gdk.get_default_root_window()
screen = root.get_screen()
screen_width, screen_height = get_screen_size(Gdk.Display.get_default())


class Highlight(Gtk.Window):
    def __init__(self):
        super().__init__(type=Gtk.WindowType.POPUP)

        # The dict looks like the following:
        # {33562868: {"lastUpdate": 1234, "isViewable": True}}
        self.viewable_window_map = {}
        self.last_viewable_window_map_cleanup = time.time()
        self.wnck_screen = Wnck.Screen.get_default()
        self.wnck_screen.force_update()
        self.set_app_paintable(True)
        screen = self.get_screen()
        visual = screen.get_rgba_visual()
        self.set_visual(visual)
        try:  # because deprecated
            self.set_wmclass("xborders", "xborder")
        except:
            pass
        self.show_all()

        self.resize(screen_width, screen_height)
        self.move(0, 0)

        self.fullscreen()
        self.set_decorated(False)
        self.set_skip_taskbar_hint(True)
        self.set_skip_pager_hint(True)
        self.set_keep_above(True)
        self.set_type_hint(Gdk.WindowTypeHint.NOTIFICATION)

        self.set_accept_focus(False)
        self.set_focus_on_map(False)

        self.drawingarea = Gtk.DrawingArea()
        self.drawingarea.set_events(Gdk.EventMask.EXPOSURE_MASK)
        self.add(self.drawingarea)
        self.input_shape_combine_region(cairo.Region())

        self.connect("draw", self._on_draw)

    def _query_window_viewable(self, window_id):
        completed_process = subprocess.run(
            ["xwininfo", "-id", f"{window_id}"], capture_output=True
        )
        if completed_process.returncode != 0:
            return None
        process_stdout = completed_process.stdout.decode("utf-8")
        is_viewable = [
            x == "IsViewable"
            for x in re.findall("(IsViewable|IsUnviewable)", process_stdout)
        ]
        return None if not is_viewable else is_viewable[0]

    def _update_viewable_window_map(self, window_id):
        is_viewable = self._query_window_viewable(window_id)
        self.viewable_window_map[window_id] = {
            "lastUpdate": time.time(),
            "isViewable": is_viewable,
        }
        return is_viewable

    def _is_window_viewable(self, window_id):
        if window_id in self.viewable_window_map:
            last_update = self.viewable_window_map[window_id]["lastUpdate"]
            if time.time() - last_update < VIEWABLE_WINDOW_MAP_UPDATE_FREQUENCY:
                return self.viewable_window_map[window_id]["isViewable"]
            else:
                return self._update_viewable_window_map(window_id)
        else:
            return self._update_viewable_window_map(window_id)

    def get_visible_windows(self) -> Generator[WinData]:
        if (
            time.time() - self.last_viewable_window_map_cleanup
            > VIEWABLE_WINDOW_MAP_CLEANUP_FREQUENCY
        ):
            self.last_viewable_window_map_cleanup = time.time()
            self.viewable_window_map = {}

        for window in self.wnck_screen.get_windows():
            if window and self._is_window_viewable(window.get_xid()):
                yield WinData(window.get_xid(), *window.get_client_window_geometry())

    notified_compositor = False
    rect_x = None
    rect_y = None

    def _on_draw(self, _wid, ctx):
        if not screen.is_composited():
            self.move(1e6, 1e6)  # move it off screen
            if self.notified_compositor:
                return
            else:
                subprocess.Popen(
                    [
                        "notify-send",
                        "xborder",
                        "xborders requires a compositor. Resuming once a compositor is found.",
                    ]
                )
                self.notified_compositor = True
        else:
            if self.notified_compositor == True:
                self.move(0, 0)
            self.notified_compositor = False
        ctx.save()

        if not is_fullscreen(self.wnck_screen):
            all_win_ids = get_ordered_window_ids()
            floating_windows = get_floating_window_ids()

            win_data = self.get_visible_windows() | tolist
            win_data: list[int] = \
                    (win_data | whereby(Get.id, Is.not_member_of(floating_windows)) | tolist) + \
                    (win_data | whereby(Get.id, Is.member_of(floating_windows)) | tolist)
            visible_win_ids = win_data | select(Get.id) | toset

            ordered_win_ids: list[int] = \
                    all_win_ids | where(Is.member_of(visible_win_ids)) | tolist

            # (x, y, width, height, window_id)[]
            win_dims = win_data | select(Get.dim) | tolist

            win_id_to_idx = {win.id: idx for idx, win in enumerate(win_data)}

            ordered_win_dims: list[WinDim] = \
                ordered_win_ids | select(lambda id: win_dims[win_id_to_idx[id]]) | tolist

            active_id = get_active_window()

            for i, win_dim in enumerate(ordered_win_dims):
                win_id = ordered_win_ids[i]

                x, y, w, h = win_dim.unpack()
                if BORDER_MODE == 0:
                    x += BORDER_WIDTH // 2
                    y += BORDER_WIDTH // 2
                    w -= BORDER_WIDTH
                    h -= BORDER_WIDTH
                elif BORDER_MODE == 1:
                    x -= BORDER_WIDTH // 2
                    y -= BORDER_WIDTH // 2
                    w += BORDER_WIDTH
                    h += BORDER_WIDTH

                current_id = ordered_win_ids[i]
                if current_id in win_id_to_idx:
                    exclusions = ordered_win_dims[win_id_to_idx[current_id] + 1 :]
                else:
                    exclusions = []

                border_color = [BORDER_R, BORDER_G, BORDER_B, BORDER_A] \
                        if win_id == active_id else \
                        [100, 100, 100, BORDER_A]

                draw.draw_rectangle(
                    ctx,
                    x,
                    y,
                    w,
                    h,
                    BORDER_RADIUS,
                    BORDER_WIDTH,
                    [0, 0, 0, 0],
                    border_color,
                    exclusions | select(Call.unpack),
                )

        ctx.restore()
        self.queue_draw()


def main():
    get_args()

    win = Highlight()
    win.connect("destroy", Gtk.main_quit)
    win.set_keep_above(True)
    win.set_title("xborders")

    win.show_all()

    Gtk.main()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        exit(0)
